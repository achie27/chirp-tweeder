/* tslint:disable */
/* eslint-disable */
/**
 * Twitter API v2
 * Twitter API v2 available endpoints
 *
 * The version of the OpenAPI document: 2.49
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { ContextAnnotation } from './ContextAnnotation';
import {
    ContextAnnotationFromJSON,
    ContextAnnotationFromJSONTyped,
    ContextAnnotationToJSON,
} from './ContextAnnotation';
import type { FullTextEntities } from './FullTextEntities';
import {
    FullTextEntitiesFromJSON,
    FullTextEntitiesFromJSONTyped,
    FullTextEntitiesToJSON,
} from './FullTextEntities';
import type { ReplySettings } from './ReplySettings';
import {
    ReplySettingsFromJSON,
    ReplySettingsFromJSONTyped,
    ReplySettingsToJSON,
} from './ReplySettings';
import type { TweetAttachments } from './TweetAttachments';
import {
    TweetAttachmentsFromJSON,
    TweetAttachmentsFromJSONTyped,
    TweetAttachmentsToJSON,
} from './TweetAttachments';
import type { TweetGeo } from './TweetGeo';
import {
    TweetGeoFromJSON,
    TweetGeoFromJSONTyped,
    TweetGeoToJSON,
} from './TweetGeo';
import type { TweetNonPublicMetrics } from './TweetNonPublicMetrics';
import {
    TweetNonPublicMetricsFromJSON,
    TweetNonPublicMetricsFromJSONTyped,
    TweetNonPublicMetricsToJSON,
} from './TweetNonPublicMetrics';
import type { TweetOrganicMetrics } from './TweetOrganicMetrics';
import {
    TweetOrganicMetricsFromJSON,
    TweetOrganicMetricsFromJSONTyped,
    TweetOrganicMetricsToJSON,
} from './TweetOrganicMetrics';
import type { TweetPromotedMetrics } from './TweetPromotedMetrics';
import {
    TweetPromotedMetricsFromJSON,
    TweetPromotedMetricsFromJSONTyped,
    TweetPromotedMetricsToJSON,
} from './TweetPromotedMetrics';
import type { TweetPublicMetrics } from './TweetPublicMetrics';
import {
    TweetPublicMetricsFromJSON,
    TweetPublicMetricsFromJSONTyped,
    TweetPublicMetricsToJSON,
} from './TweetPublicMetrics';
import type { TweetReferencedTweetsInner } from './TweetReferencedTweetsInner';
import {
    TweetReferencedTweetsInnerFromJSON,
    TweetReferencedTweetsInnerFromJSONTyped,
    TweetReferencedTweetsInnerToJSON,
} from './TweetReferencedTweetsInner';
import type { TweetWithheld } from './TweetWithheld';
import {
    TweetWithheldFromJSON,
    TweetWithheldFromJSONTyped,
    TweetWithheldToJSON,
} from './TweetWithheld';

/**
 * 
 * @export
 * @interface Tweet
 */
export interface Tweet {
    /**
     * 
     * @type {TweetAttachments}
     * @memberof Tweet
     */
    attachments?: TweetAttachments;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    authorId?: string;
    /**
     * 
     * @type {Array<ContextAnnotation>}
     * @memberof Tweet
     */
    contextAnnotations?: Array<ContextAnnotation>;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    conversationId?: string;
    /**
     * Creation time of the Tweet.
     * @type {Date}
     * @memberof Tweet
     */
    createdAt?: Date;
    /**
     * 
     * @type {FullTextEntities}
     * @memberof Tweet
     */
    entities?: FullTextEntities;
    /**
     * 
     * @type {TweetGeo}
     * @memberof Tweet
     */
    geo?: TweetGeo;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    id: string;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    inReplyToUserId?: string;
    /**
     * Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag.
     * @type {string}
     * @memberof Tweet
     */
    lang?: string;
    /**
     * 
     * @type {TweetNonPublicMetrics}
     * @memberof Tweet
     */
    nonPublicMetrics?: TweetNonPublicMetrics;
    /**
     * 
     * @type {TweetOrganicMetrics}
     * @memberof Tweet
     */
    organicMetrics?: TweetOrganicMetrics;
    /**
     * Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences.
     * @type {boolean}
     * @memberof Tweet
     */
    possiblySensitive?: boolean;
    /**
     * 
     * @type {TweetPromotedMetrics}
     * @memberof Tweet
     */
    promotedMetrics?: TweetPromotedMetrics;
    /**
     * 
     * @type {TweetPublicMetrics}
     * @memberof Tweet
     */
    publicMetrics?: TweetPublicMetrics;
    /**
     * A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent.
     * @type {Array<TweetReferencedTweetsInner>}
     * @memberof Tweet
     */
    referencedTweets?: Array<TweetReferencedTweetsInner>;
    /**
     * 
     * @type {ReplySettings}
     * @memberof Tweet
     */
    replySettings?: ReplySettings;
    /**
     * The name of the app the user Tweeted from.
     * @type {string}
     * @memberof Tweet
     */
    source?: string;
    /**
     * The content of the Tweet.
     * @type {string}
     * @memberof Tweet
     */
    text: string;
    /**
     * 
     * @type {TweetWithheld}
     * @memberof Tweet
     */
    withheld?: TweetWithheld;
}

/**
 * Check if a given object implements the Tweet interface.
 */
export function instanceOfTweet(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "id" in value;
    isInstance = isInstance && "text" in value;

    return isInstance;
}

export function TweetFromJSON(json: any): Tweet {
    return TweetFromJSONTyped(json, false);
}

export function TweetFromJSONTyped(json: any, ignoreDiscriminator: boolean): Tweet {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'attachments': !exists(json, 'attachments') ? undefined : TweetAttachmentsFromJSON(json['attachments']),
        'authorId': !exists(json, 'author_id') ? undefined : json['author_id'],
        'contextAnnotations': !exists(json, 'context_annotations') ? undefined : ((json['context_annotations'] as Array<any>).map(ContextAnnotationFromJSON)),
        'conversationId': !exists(json, 'conversation_id') ? undefined : json['conversation_id'],
        'createdAt': !exists(json, 'created_at') ? undefined : (new Date(json['created_at'])),
        'entities': !exists(json, 'entities') ? undefined : FullTextEntitiesFromJSON(json['entities']),
        'geo': !exists(json, 'geo') ? undefined : TweetGeoFromJSON(json['geo']),
        'id': json['id'],
        'inReplyToUserId': !exists(json, 'in_reply_to_user_id') ? undefined : json['in_reply_to_user_id'],
        'lang': !exists(json, 'lang') ? undefined : json['lang'],
        'nonPublicMetrics': !exists(json, 'non_public_metrics') ? undefined : TweetNonPublicMetricsFromJSON(json['non_public_metrics']),
        'organicMetrics': !exists(json, 'organic_metrics') ? undefined : TweetOrganicMetricsFromJSON(json['organic_metrics']),
        'possiblySensitive': !exists(json, 'possibly_sensitive') ? undefined : json['possibly_sensitive'],
        'promotedMetrics': !exists(json, 'promoted_metrics') ? undefined : TweetPromotedMetricsFromJSON(json['promoted_metrics']),
        'publicMetrics': !exists(json, 'public_metrics') ? undefined : TweetPublicMetricsFromJSON(json['public_metrics']),
        'referencedTweets': !exists(json, 'referenced_tweets') ? undefined : ((json['referenced_tweets'] as Array<any>).map(TweetReferencedTweetsInnerFromJSON)),
        'replySettings': !exists(json, 'reply_settings') ? undefined : ReplySettingsFromJSON(json['reply_settings']),
        'source': !exists(json, 'source') ? undefined : json['source'],
        'text': json['text'],
        'withheld': !exists(json, 'withheld') ? undefined : TweetWithheldFromJSON(json['withheld']),
    };
}

export function TweetToJSON(value?: Tweet | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'attachments': TweetAttachmentsToJSON(value.attachments),
        'author_id': value.authorId,
        'context_annotations': value.contextAnnotations === undefined ? undefined : ((value.contextAnnotations as Array<any>).map(ContextAnnotationToJSON)),
        'conversation_id': value.conversationId,
        'created_at': value.createdAt === undefined ? undefined : (value.createdAt.toISOString()),
        'entities': FullTextEntitiesToJSON(value.entities),
        'geo': TweetGeoToJSON(value.geo),
        'id': value.id,
        'in_reply_to_user_id': value.inReplyToUserId,
        'lang': value.lang,
        'non_public_metrics': TweetNonPublicMetricsToJSON(value.nonPublicMetrics),
        'organic_metrics': TweetOrganicMetricsToJSON(value.organicMetrics),
        'possibly_sensitive': value.possiblySensitive,
        'promoted_metrics': TweetPromotedMetricsToJSON(value.promotedMetrics),
        'public_metrics': TweetPublicMetricsToJSON(value.publicMetrics),
        'referenced_tweets': value.referencedTweets === undefined ? undefined : ((value.referencedTweets as Array<any>).map(TweetReferencedTweetsInnerToJSON)),
        'reply_settings': ReplySettingsToJSON(value.replySettings),
        'source': value.source,
        'text': value.text,
        'withheld': TweetWithheldToJSON(value.withheld),
    };
}

