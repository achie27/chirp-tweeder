/* tslint:disable */
/* eslint-disable */
/**
 * Twitter API v2
 * Twitter API v2 available endpoints
 *
 * The version of the OpenAPI document: 2.49
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BlockUserMutationResponse,
  BlockUserRequest,
  Get2ListsIdFollowersResponse,
  Get2ListsIdMembersResponse,
  Get2TweetsIdLikingUsersResponse,
  Get2TweetsIdRetweetedByResponse,
  Get2UsersByResponse,
  Get2UsersByUsernameUsernameResponse,
  Get2UsersIdBlockingResponse,
  Get2UsersIdFollowersResponse,
  Get2UsersIdFollowingResponse,
  Get2UsersIdMutingResponse,
  Get2UsersIdResponse,
  Get2UsersMeResponse,
  Get2UsersResponse,
  MuteUserMutationResponse,
  MuteUserRequest,
  Problem,
  UsersFollowingCreateRequest,
  UsersFollowingCreateResponse,
  UsersFollowingDeleteResponse,
} from '../models';
import {
    BlockUserMutationResponseFromJSON,
    BlockUserMutationResponseToJSON,
    BlockUserRequestFromJSON,
    BlockUserRequestToJSON,
    Get2ListsIdFollowersResponseFromJSON,
    Get2ListsIdFollowersResponseToJSON,
    Get2ListsIdMembersResponseFromJSON,
    Get2ListsIdMembersResponseToJSON,
    Get2TweetsIdLikingUsersResponseFromJSON,
    Get2TweetsIdLikingUsersResponseToJSON,
    Get2TweetsIdRetweetedByResponseFromJSON,
    Get2TweetsIdRetweetedByResponseToJSON,
    Get2UsersByResponseFromJSON,
    Get2UsersByResponseToJSON,
    Get2UsersByUsernameUsernameResponseFromJSON,
    Get2UsersByUsernameUsernameResponseToJSON,
    Get2UsersIdBlockingResponseFromJSON,
    Get2UsersIdBlockingResponseToJSON,
    Get2UsersIdFollowersResponseFromJSON,
    Get2UsersIdFollowersResponseToJSON,
    Get2UsersIdFollowingResponseFromJSON,
    Get2UsersIdFollowingResponseToJSON,
    Get2UsersIdMutingResponseFromJSON,
    Get2UsersIdMutingResponseToJSON,
    Get2UsersIdResponseFromJSON,
    Get2UsersIdResponseToJSON,
    Get2UsersMeResponseFromJSON,
    Get2UsersMeResponseToJSON,
    Get2UsersResponseFromJSON,
    Get2UsersResponseToJSON,
    MuteUserMutationResponseFromJSON,
    MuteUserMutationResponseToJSON,
    MuteUserRequestFromJSON,
    MuteUserRequestToJSON,
    ProblemFromJSON,
    ProblemToJSON,
    UsersFollowingCreateRequestFromJSON,
    UsersFollowingCreateRequestToJSON,
    UsersFollowingCreateResponseFromJSON,
    UsersFollowingCreateResponseToJSON,
    UsersFollowingDeleteResponseFromJSON,
    UsersFollowingDeleteResponseToJSON,
} from '../models';

export interface FindMyUserRequest {
    userFields?: Set<FindMyUserUserFieldsEnum>;
    expansions?: Set<FindMyUserExpansionsEnum>;
    tweetFields?: Set<FindMyUserTweetFieldsEnum>;
}

export interface FindUserByIdRequest {
    id: string;
    userFields?: Set<FindUserByIdUserFieldsEnum>;
    expansions?: Set<FindUserByIdExpansionsEnum>;
    tweetFields?: Set<FindUserByIdTweetFieldsEnum>;
}

export interface FindUserByUsernameRequest {
    username: string;
    userFields?: Set<FindUserByUsernameUserFieldsEnum>;
    expansions?: Set<FindUserByUsernameExpansionsEnum>;
    tweetFields?: Set<FindUserByUsernameTweetFieldsEnum>;
}

export interface FindUsersByIdRequest {
    ids: Array<string>;
    userFields?: Set<FindUsersByIdUserFieldsEnum>;
    expansions?: Set<FindUsersByIdExpansionsEnum>;
    tweetFields?: Set<FindUsersByIdTweetFieldsEnum>;
}

export interface FindUsersByUsernameRequest {
    usernames: Array<string>;
    userFields?: Set<FindUsersByUsernameUserFieldsEnum>;
    expansions?: Set<FindUsersByUsernameExpansionsEnum>;
    tweetFields?: Set<FindUsersByUsernameTweetFieldsEnum>;
}

export interface ListGetFollowersRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    userFields?: Set<ListGetFollowersUserFieldsEnum>;
    expansions?: Set<ListGetFollowersExpansionsEnum>;
    tweetFields?: Set<ListGetFollowersTweetFieldsEnum>;
}

export interface ListGetMembersRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    userFields?: Set<ListGetMembersUserFieldsEnum>;
    expansions?: Set<ListGetMembersExpansionsEnum>;
    tweetFields?: Set<ListGetMembersTweetFieldsEnum>;
}

export interface TweetsIdLikingUsersRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    userFields?: Set<TweetsIdLikingUsersUserFieldsEnum>;
    expansions?: Set<TweetsIdLikingUsersExpansionsEnum>;
    tweetFields?: Set<TweetsIdLikingUsersTweetFieldsEnum>;
}

export interface TweetsIdRetweetingUsersRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    userFields?: Set<TweetsIdRetweetingUsersUserFieldsEnum>;
    expansions?: Set<TweetsIdRetweetingUsersExpansionsEnum>;
    tweetFields?: Set<TweetsIdRetweetingUsersTweetFieldsEnum>;
}

export interface UsersIdBlockRequest {
    id: string;
    blockUserRequest: BlockUserRequest;
}

export interface UsersIdBlockingRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    userFields?: Set<UsersIdBlockingUserFieldsEnum>;
    expansions?: Set<UsersIdBlockingExpansionsEnum>;
    tweetFields?: Set<UsersIdBlockingTweetFieldsEnum>;
}

export interface UsersIdFollowRequest {
    id: string;
    usersFollowingCreateRequest?: UsersFollowingCreateRequest;
}

export interface UsersIdFollowersRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    userFields?: Set<UsersIdFollowersUserFieldsEnum>;
    expansions?: Set<UsersIdFollowersExpansionsEnum>;
    tweetFields?: Set<UsersIdFollowersTweetFieldsEnum>;
}

export interface UsersIdFollowingRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    userFields?: Set<UsersIdFollowingUserFieldsEnum>;
    expansions?: Set<UsersIdFollowingExpansionsEnum>;
    tweetFields?: Set<UsersIdFollowingTweetFieldsEnum>;
}

export interface UsersIdMuteRequest {
    id: string;
    muteUserRequest?: MuteUserRequest;
}

export interface UsersIdMutingRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    userFields?: Set<UsersIdMutingUserFieldsEnum>;
    expansions?: Set<UsersIdMutingExpansionsEnum>;
    tweetFields?: Set<UsersIdMutingTweetFieldsEnum>;
}

export interface UsersIdUnblockRequest {
    sourceUserId: string;
    targetUserId: string;
}

export interface UsersIdUnfollowRequest {
    sourceUserId: string;
    targetUserId: string;
}

export interface UsersIdUnmuteRequest {
    sourceUserId: string;
    targetUserId: string;
}

/**
 * 
 */
export class UsersApi extends runtime.BaseAPI {

    /**
     * This endpoint returns information about the requesting User.
     * User lookup me
     */
    async findMyUserRaw(requestParameters: FindMyUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersMeResponse>> {
        const queryParameters: any = {};

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/users/me`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersMeResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint returns information about the requesting User.
     * User lookup me
     */
    async findMyUser(requestParameters: FindMyUserRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersMeResponse> {
        const response = await this.findMyUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns information about a User. Specify User by ID.
     * User lookup by ID
     */
    async findUserByIdRaw(requestParameters: FindUserByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersIdResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling findUserById.');
        }

        const queryParameters: any = {};

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/users/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersIdResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint returns information about a User. Specify User by ID.
     * User lookup by ID
     */
    async findUserById(requestParameters: FindUserByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersIdResponse> {
        const response = await this.findUserByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns information about a User. Specify User by username.
     * User lookup by username
     */
    async findUserByUsernameRaw(requestParameters: FindUserByUsernameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersByUsernameUsernameResponse>> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling findUserByUsername.');
        }

        const queryParameters: any = {};

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/users/by/username/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersByUsernameUsernameResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint returns information about a User. Specify User by username.
     * User lookup by username
     */
    async findUserByUsername(requestParameters: FindUserByUsernameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersByUsernameUsernameResponse> {
        const response = await this.findUserByUsernameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns information about Users. Specify Users by their ID.
     * User lookup by IDs
     */
    async findUsersByIdRaw(requestParameters: FindUsersByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter requestParameters.ids was null or undefined when calling findUsersById.');
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint returns information about Users. Specify Users by their ID.
     * User lookup by IDs
     */
    async findUsersById(requestParameters: FindUsersByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersResponse> {
        const response = await this.findUsersByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This endpoint returns information about Users. Specify Users by their username.
     * User lookup by usernames
     */
    async findUsersByUsernameRaw(requestParameters: FindUsersByUsernameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersByResponse>> {
        if (requestParameters.usernames === null || requestParameters.usernames === undefined) {
            throw new runtime.RequiredError('usernames','Required parameter requestParameters.usernames was null or undefined when calling findUsersByUsername.');
        }

        const queryParameters: any = {};

        if (requestParameters.usernames) {
            queryParameters['usernames'] = requestParameters.usernames.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/users/by`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersByResponseFromJSON(jsonValue));
    }

    /**
     * This endpoint returns information about Users. Specify Users by their username.
     * User lookup by usernames
     */
    async findUsersByUsername(requestParameters: FindUsersByUsernameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersByResponse> {
        const response = await this.findUsersByUsernameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Users that follow a List by the provided List ID
     * Returns User objects that follow a List by the provided List ID
     */
    async listGetFollowersRaw(requestParameters: ListGetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2ListsIdFollowersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listGetFollowers.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "list.read"]);
        }

        const response = await this.request({
            path: `/2/lists/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2ListsIdFollowersResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Users that follow a List by the provided List ID
     * Returns User objects that follow a List by the provided List ID
     */
    async listGetFollowers(requestParameters: ListGetFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2ListsIdFollowersResponse> {
        const response = await this.listGetFollowersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Users that are members of a List by the provided List ID.
     * Returns User objects that are members of a List by the provided List ID.
     */
    async listGetMembersRaw(requestParameters: ListGetMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2ListsIdMembersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listGetMembers.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "list.read"]);
        }

        const response = await this.request({
            path: `/2/lists/{id}/members`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2ListsIdMembersResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Users that are members of a List by the provided List ID.
     * Returns User objects that are members of a List by the provided List ID.
     */
    async listGetMembers(requestParameters: ListGetMembersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2ListsIdMembersResponse> {
        const response = await this.listGetMembersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Users that have liked the provided Tweet ID
     * Returns User objects that have liked the provided Tweet ID
     */
    async tweetsIdLikingUsersRaw(requestParameters: TweetsIdLikingUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsIdLikingUsersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling tweetsIdLikingUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "like.read"]);
        }

        const response = await this.request({
            path: `/2/tweets/{id}/liking_users`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsIdLikingUsersResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Users that have liked the provided Tweet ID
     * Returns User objects that have liked the provided Tweet ID
     */
    async tweetsIdLikingUsers(requestParameters: TweetsIdLikingUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsIdLikingUsersResponse> {
        const response = await this.tweetsIdLikingUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Users that have retweeted the provided Tweet ID
     * Returns User objects that have retweeted the provided Tweet ID
     */
    async tweetsIdRetweetingUsersRaw(requestParameters: TweetsIdRetweetingUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsIdRetweetedByResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling tweetsIdRetweetingUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/tweets/{id}/retweeted_by`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsIdRetweetedByResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Users that have retweeted the provided Tweet ID
     * Returns User objects that have retweeted the provided Tweet ID
     */
    async tweetsIdRetweetingUsers(requestParameters: TweetsIdRetweetingUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsIdRetweetedByResponse> {
        const response = await this.tweetsIdRetweetingUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
     * Block User by User ID
     */
    async usersIdBlockRaw(requestParameters: UsersIdBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockUserMutationResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdBlock.');
        }

        if (requestParameters.blockUserRequest === null || requestParameters.blockUserRequest === undefined) {
            throw new runtime.RequiredError('blockUserRequest','Required parameter requestParameters.blockUserRequest was null or undefined when calling usersIdBlock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read", "block.write"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/blocking`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BlockUserRequestToJSON(requestParameters.blockUserRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockUserMutationResponseFromJSON(jsonValue));
    }

    /**
     * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
     * Block User by User ID
     */
    async usersIdBlock(requestParameters: UsersIdBlockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockUserMutationResponse> {
        const response = await this.usersIdBlockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Users that are blocked by the provided User ID
     * Returns User objects that are blocked by provided User ID
     */
    async usersIdBlockingRaw(requestParameters: UsersIdBlockingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersIdBlockingResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdBlocking.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read", "block.read"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/blocking`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersIdBlockingResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Users that are blocked by the provided User ID
     * Returns User objects that are blocked by provided User ID
     */
    async usersIdBlocking(requestParameters: UsersIdBlockingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersIdBlockingResponse> {
        const response = await this.usersIdBlockingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
     * Follow User
     */
    async usersIdFollowRaw(requestParameters: UsersIdFollowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersFollowingCreateResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdFollow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "follows.write"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UsersFollowingCreateRequestToJSON(requestParameters.usersFollowingCreateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersFollowingCreateResponseFromJSON(jsonValue));
    }

    /**
     * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
     * Follow User
     */
    async usersIdFollow(requestParameters: UsersIdFollowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersFollowingCreateResponse> {
        const response = await this.usersIdFollowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Users that follow the provided User ID
     * Returns User objects that follow a List by the provided User ID
     */
    async usersIdFollowersRaw(requestParameters: UsersIdFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersIdFollowersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdFollowers.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "follows.read"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/followers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersIdFollowersResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Users that follow the provided User ID
     * Returns User objects that follow a List by the provided User ID
     */
    async usersIdFollowers(requestParameters: UsersIdFollowersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersIdFollowersResponse> {
        const response = await this.usersIdFollowersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Users that are being followed by the provided User ID
     * Following by User ID
     */
    async usersIdFollowingRaw(requestParameters: UsersIdFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersIdFollowingResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdFollowing.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "follows.read"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/following`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersIdFollowingResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Users that are being followed by the provided User ID
     * Following by User ID
     */
    async usersIdFollowing(requestParameters: UsersIdFollowingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersIdFollowingResponse> {
        const response = await this.usersIdFollowingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
     * Mute User by User ID.
     */
    async usersIdMuteRaw(requestParameters: UsersIdMuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteUserMutationResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdMute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read", "mute.write"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/muting`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MuteUserRequestToJSON(requestParameters.muteUserRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MuteUserMutationResponseFromJSON(jsonValue));
    }

    /**
     * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
     * Mute User by User ID.
     */
    async usersIdMute(requestParameters: UsersIdMuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteUserMutationResponse> {
        const response = await this.usersIdMuteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Users that are muted by the provided User ID
     * Returns User objects that are muted by the provided User ID
     */
    async usersIdMutingRaw(requestParameters: UsersIdMutingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersIdMutingResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdMuting.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read", "mute.read"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/muting`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersIdMutingResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Users that are muted by the provided User ID
     * Returns User objects that are muted by the provided User ID
     */
    async usersIdMuting(requestParameters: UsersIdMutingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersIdMutingResponse> {
        const response = await this.usersIdMutingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
     * Unblock User by User ID
     */
    async usersIdUnblockRaw(requestParameters: UsersIdUnblockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BlockUserMutationResponse>> {
        if (requestParameters.sourceUserId === null || requestParameters.sourceUserId === undefined) {
            throw new runtime.RequiredError('sourceUserId','Required parameter requestParameters.sourceUserId was null or undefined when calling usersIdUnblock.');
        }

        if (requestParameters.targetUserId === null || requestParameters.targetUserId === undefined) {
            throw new runtime.RequiredError('targetUserId','Required parameter requestParameters.targetUserId was null or undefined when calling usersIdUnblock.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read", "block.write"]);
        }

        const response = await this.request({
            path: `/2/users/{source_user_id}/blocking/{target_user_id}`.replace(`{${"source_user_id"}}`, encodeURIComponent(String(requestParameters.sourceUserId))).replace(`{${"target_user_id"}}`, encodeURIComponent(String(requestParameters.targetUserId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BlockUserMutationResponseFromJSON(jsonValue));
    }

    /**
     * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
     * Unblock User by User ID
     */
    async usersIdUnblock(requestParameters: UsersIdUnblockRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BlockUserMutationResponse> {
        const response = await this.usersIdUnblockRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
     * Unfollow User
     */
    async usersIdUnfollowRaw(requestParameters: UsersIdUnfollowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersFollowingDeleteResponse>> {
        if (requestParameters.sourceUserId === null || requestParameters.sourceUserId === undefined) {
            throw new runtime.RequiredError('sourceUserId','Required parameter requestParameters.sourceUserId was null or undefined when calling usersIdUnfollow.');
        }

        if (requestParameters.targetUserId === null || requestParameters.targetUserId === undefined) {
            throw new runtime.RequiredError('targetUserId','Required parameter requestParameters.targetUserId was null or undefined when calling usersIdUnfollow.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "follows.write"]);
        }

        const response = await this.request({
            path: `/2/users/{source_user_id}/following/{target_user_id}`.replace(`{${"source_user_id"}}`, encodeURIComponent(String(requestParameters.sourceUserId))).replace(`{${"target_user_id"}}`, encodeURIComponent(String(requestParameters.targetUserId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersFollowingDeleteResponseFromJSON(jsonValue));
    }

    /**
     * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
     * Unfollow User
     */
    async usersIdUnfollow(requestParameters: UsersIdUnfollowRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersFollowingDeleteResponse> {
        const response = await this.usersIdUnfollowRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
     * Unmute User by User ID
     */
    async usersIdUnmuteRaw(requestParameters: UsersIdUnmuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MuteUserMutationResponse>> {
        if (requestParameters.sourceUserId === null || requestParameters.sourceUserId === undefined) {
            throw new runtime.RequiredError('sourceUserId','Required parameter requestParameters.sourceUserId was null or undefined when calling usersIdUnmute.');
        }

        if (requestParameters.targetUserId === null || requestParameters.targetUserId === undefined) {
            throw new runtime.RequiredError('targetUserId','Required parameter requestParameters.targetUserId was null or undefined when calling usersIdUnmute.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read", "mute.write"]);
        }

        const response = await this.request({
            path: `/2/users/{source_user_id}/muting/{target_user_id}`.replace(`{${"source_user_id"}}`, encodeURIComponent(String(requestParameters.sourceUserId))).replace(`{${"target_user_id"}}`, encodeURIComponent(String(requestParameters.targetUserId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MuteUserMutationResponseFromJSON(jsonValue));
    }

    /**
     * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
     * Unmute User by User ID
     */
    async usersIdUnmute(requestParameters: UsersIdUnmuteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MuteUserMutationResponse> {
        const response = await this.usersIdUnmuteRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const FindMyUserUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type FindMyUserUserFieldsEnum = typeof FindMyUserUserFieldsEnum[keyof typeof FindMyUserUserFieldsEnum];
/**
 * @export
 */
export const FindMyUserExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type FindMyUserExpansionsEnum = typeof FindMyUserExpansionsEnum[keyof typeof FindMyUserExpansionsEnum];
/**
 * @export
 */
export const FindMyUserTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type FindMyUserTweetFieldsEnum = typeof FindMyUserTweetFieldsEnum[keyof typeof FindMyUserTweetFieldsEnum];
/**
 * @export
 */
export const FindUserByIdUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type FindUserByIdUserFieldsEnum = typeof FindUserByIdUserFieldsEnum[keyof typeof FindUserByIdUserFieldsEnum];
/**
 * @export
 */
export const FindUserByIdExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type FindUserByIdExpansionsEnum = typeof FindUserByIdExpansionsEnum[keyof typeof FindUserByIdExpansionsEnum];
/**
 * @export
 */
export const FindUserByIdTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type FindUserByIdTweetFieldsEnum = typeof FindUserByIdTweetFieldsEnum[keyof typeof FindUserByIdTweetFieldsEnum];
/**
 * @export
 */
export const FindUserByUsernameUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type FindUserByUsernameUserFieldsEnum = typeof FindUserByUsernameUserFieldsEnum[keyof typeof FindUserByUsernameUserFieldsEnum];
/**
 * @export
 */
export const FindUserByUsernameExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type FindUserByUsernameExpansionsEnum = typeof FindUserByUsernameExpansionsEnum[keyof typeof FindUserByUsernameExpansionsEnum];
/**
 * @export
 */
export const FindUserByUsernameTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type FindUserByUsernameTweetFieldsEnum = typeof FindUserByUsernameTweetFieldsEnum[keyof typeof FindUserByUsernameTweetFieldsEnum];
/**
 * @export
 */
export const FindUsersByIdUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type FindUsersByIdUserFieldsEnum = typeof FindUsersByIdUserFieldsEnum[keyof typeof FindUsersByIdUserFieldsEnum];
/**
 * @export
 */
export const FindUsersByIdExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type FindUsersByIdExpansionsEnum = typeof FindUsersByIdExpansionsEnum[keyof typeof FindUsersByIdExpansionsEnum];
/**
 * @export
 */
export const FindUsersByIdTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type FindUsersByIdTweetFieldsEnum = typeof FindUsersByIdTweetFieldsEnum[keyof typeof FindUsersByIdTweetFieldsEnum];
/**
 * @export
 */
export const FindUsersByUsernameUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type FindUsersByUsernameUserFieldsEnum = typeof FindUsersByUsernameUserFieldsEnum[keyof typeof FindUsersByUsernameUserFieldsEnum];
/**
 * @export
 */
export const FindUsersByUsernameExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type FindUsersByUsernameExpansionsEnum = typeof FindUsersByUsernameExpansionsEnum[keyof typeof FindUsersByUsernameExpansionsEnum];
/**
 * @export
 */
export const FindUsersByUsernameTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type FindUsersByUsernameTweetFieldsEnum = typeof FindUsersByUsernameTweetFieldsEnum[keyof typeof FindUsersByUsernameTweetFieldsEnum];
/**
 * @export
 */
export const ListGetFollowersUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type ListGetFollowersUserFieldsEnum = typeof ListGetFollowersUserFieldsEnum[keyof typeof ListGetFollowersUserFieldsEnum];
/**
 * @export
 */
export const ListGetFollowersExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type ListGetFollowersExpansionsEnum = typeof ListGetFollowersExpansionsEnum[keyof typeof ListGetFollowersExpansionsEnum];
/**
 * @export
 */
export const ListGetFollowersTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type ListGetFollowersTweetFieldsEnum = typeof ListGetFollowersTweetFieldsEnum[keyof typeof ListGetFollowersTweetFieldsEnum];
/**
 * @export
 */
export const ListGetMembersUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type ListGetMembersUserFieldsEnum = typeof ListGetMembersUserFieldsEnum[keyof typeof ListGetMembersUserFieldsEnum];
/**
 * @export
 */
export const ListGetMembersExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type ListGetMembersExpansionsEnum = typeof ListGetMembersExpansionsEnum[keyof typeof ListGetMembersExpansionsEnum];
/**
 * @export
 */
export const ListGetMembersTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type ListGetMembersTweetFieldsEnum = typeof ListGetMembersTweetFieldsEnum[keyof typeof ListGetMembersTweetFieldsEnum];
/**
 * @export
 */
export const TweetsIdLikingUsersUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type TweetsIdLikingUsersUserFieldsEnum = typeof TweetsIdLikingUsersUserFieldsEnum[keyof typeof TweetsIdLikingUsersUserFieldsEnum];
/**
 * @export
 */
export const TweetsIdLikingUsersExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type TweetsIdLikingUsersExpansionsEnum = typeof TweetsIdLikingUsersExpansionsEnum[keyof typeof TweetsIdLikingUsersExpansionsEnum];
/**
 * @export
 */
export const TweetsIdLikingUsersTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type TweetsIdLikingUsersTweetFieldsEnum = typeof TweetsIdLikingUsersTweetFieldsEnum[keyof typeof TweetsIdLikingUsersTweetFieldsEnum];
/**
 * @export
 */
export const TweetsIdRetweetingUsersUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type TweetsIdRetweetingUsersUserFieldsEnum = typeof TweetsIdRetweetingUsersUserFieldsEnum[keyof typeof TweetsIdRetweetingUsersUserFieldsEnum];
/**
 * @export
 */
export const TweetsIdRetweetingUsersExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type TweetsIdRetweetingUsersExpansionsEnum = typeof TweetsIdRetweetingUsersExpansionsEnum[keyof typeof TweetsIdRetweetingUsersExpansionsEnum];
/**
 * @export
 */
export const TweetsIdRetweetingUsersTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type TweetsIdRetweetingUsersTweetFieldsEnum = typeof TweetsIdRetweetingUsersTweetFieldsEnum[keyof typeof TweetsIdRetweetingUsersTweetFieldsEnum];
/**
 * @export
 */
export const UsersIdBlockingUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type UsersIdBlockingUserFieldsEnum = typeof UsersIdBlockingUserFieldsEnum[keyof typeof UsersIdBlockingUserFieldsEnum];
/**
 * @export
 */
export const UsersIdBlockingExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type UsersIdBlockingExpansionsEnum = typeof UsersIdBlockingExpansionsEnum[keyof typeof UsersIdBlockingExpansionsEnum];
/**
 * @export
 */
export const UsersIdBlockingTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type UsersIdBlockingTweetFieldsEnum = typeof UsersIdBlockingTweetFieldsEnum[keyof typeof UsersIdBlockingTweetFieldsEnum];
/**
 * @export
 */
export const UsersIdFollowersUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type UsersIdFollowersUserFieldsEnum = typeof UsersIdFollowersUserFieldsEnum[keyof typeof UsersIdFollowersUserFieldsEnum];
/**
 * @export
 */
export const UsersIdFollowersExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type UsersIdFollowersExpansionsEnum = typeof UsersIdFollowersExpansionsEnum[keyof typeof UsersIdFollowersExpansionsEnum];
/**
 * @export
 */
export const UsersIdFollowersTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type UsersIdFollowersTweetFieldsEnum = typeof UsersIdFollowersTweetFieldsEnum[keyof typeof UsersIdFollowersTweetFieldsEnum];
/**
 * @export
 */
export const UsersIdFollowingUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type UsersIdFollowingUserFieldsEnum = typeof UsersIdFollowingUserFieldsEnum[keyof typeof UsersIdFollowingUserFieldsEnum];
/**
 * @export
 */
export const UsersIdFollowingExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type UsersIdFollowingExpansionsEnum = typeof UsersIdFollowingExpansionsEnum[keyof typeof UsersIdFollowingExpansionsEnum];
/**
 * @export
 */
export const UsersIdFollowingTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type UsersIdFollowingTweetFieldsEnum = typeof UsersIdFollowingTweetFieldsEnum[keyof typeof UsersIdFollowingTweetFieldsEnum];
/**
 * @export
 */
export const UsersIdMutingUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type UsersIdMutingUserFieldsEnum = typeof UsersIdMutingUserFieldsEnum[keyof typeof UsersIdMutingUserFieldsEnum];
/**
 * @export
 */
export const UsersIdMutingExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type UsersIdMutingExpansionsEnum = typeof UsersIdMutingExpansionsEnum[keyof typeof UsersIdMutingExpansionsEnum];
/**
 * @export
 */
export const UsersIdMutingTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type UsersIdMutingTweetFieldsEnum = typeof UsersIdMutingTweetFieldsEnum[keyof typeof UsersIdMutingTweetFieldsEnum];
