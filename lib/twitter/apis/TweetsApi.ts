/* tslint:disable */
/* eslint-disable */
/**
 * Twitter API v2
 * Twitter API v2 available endpoints
 *
 * The version of the OpenAPI document: 2.49
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddOrDeleteRulesRequest,
  AddOrDeleteRulesResponse,
  FilteredStreamingTweetResponse,
  Get2ListsIdTweetsResponse,
  Get2SpacesIdBuyersResponse,
  Get2SpacesIdTweetsResponse,
  Get2TweetsCountsAllResponse,
  Get2TweetsCountsRecentResponse,
  Get2TweetsIdQuoteTweetsResponse,
  Get2TweetsIdResponse,
  Get2TweetsResponse,
  Get2TweetsSample10StreamResponse,
  Get2TweetsSearchAllResponse,
  Get2TweetsSearchRecentResponse,
  Get2UsersIdLikedTweetsResponse,
  Get2UsersIdMentionsResponse,
  Get2UsersIdTimelinesReverseChronologicalResponse,
  Get2UsersIdTweetsResponse,
  Problem,
  RulesLookupResponse,
  StreamingTweetResponse,
  TweetCreateRequest,
  TweetCreateResponse,
  TweetDeleteResponse,
  TweetHideRequest,
  TweetHideResponse,
  UsersLikesCreateRequest,
  UsersLikesCreateResponse,
  UsersLikesDeleteResponse,
  UsersRetweetsCreateRequest,
  UsersRetweetsCreateResponse,
  UsersRetweetsDeleteResponse,
} from '../models';
import {
    AddOrDeleteRulesRequestFromJSON,
    AddOrDeleteRulesRequestToJSON,
    AddOrDeleteRulesResponseFromJSON,
    AddOrDeleteRulesResponseToJSON,
    FilteredStreamingTweetResponseFromJSON,
    FilteredStreamingTweetResponseToJSON,
    Get2ListsIdTweetsResponseFromJSON,
    Get2ListsIdTweetsResponseToJSON,
    Get2SpacesIdBuyersResponseFromJSON,
    Get2SpacesIdBuyersResponseToJSON,
    Get2SpacesIdTweetsResponseFromJSON,
    Get2SpacesIdTweetsResponseToJSON,
    Get2TweetsCountsAllResponseFromJSON,
    Get2TweetsCountsAllResponseToJSON,
    Get2TweetsCountsRecentResponseFromJSON,
    Get2TweetsCountsRecentResponseToJSON,
    Get2TweetsIdQuoteTweetsResponseFromJSON,
    Get2TweetsIdQuoteTweetsResponseToJSON,
    Get2TweetsIdResponseFromJSON,
    Get2TweetsIdResponseToJSON,
    Get2TweetsResponseFromJSON,
    Get2TweetsResponseToJSON,
    Get2TweetsSample10StreamResponseFromJSON,
    Get2TweetsSample10StreamResponseToJSON,
    Get2TweetsSearchAllResponseFromJSON,
    Get2TweetsSearchAllResponseToJSON,
    Get2TweetsSearchRecentResponseFromJSON,
    Get2TweetsSearchRecentResponseToJSON,
    Get2UsersIdLikedTweetsResponseFromJSON,
    Get2UsersIdLikedTweetsResponseToJSON,
    Get2UsersIdMentionsResponseFromJSON,
    Get2UsersIdMentionsResponseToJSON,
    Get2UsersIdTimelinesReverseChronologicalResponseFromJSON,
    Get2UsersIdTimelinesReverseChronologicalResponseToJSON,
    Get2UsersIdTweetsResponseFromJSON,
    Get2UsersIdTweetsResponseToJSON,
    ProblemFromJSON,
    ProblemToJSON,
    RulesLookupResponseFromJSON,
    RulesLookupResponseToJSON,
    StreamingTweetResponseFromJSON,
    StreamingTweetResponseToJSON,
    TweetCreateRequestFromJSON,
    TweetCreateRequestToJSON,
    TweetCreateResponseFromJSON,
    TweetCreateResponseToJSON,
    TweetDeleteResponseFromJSON,
    TweetDeleteResponseToJSON,
    TweetHideRequestFromJSON,
    TweetHideRequestToJSON,
    TweetHideResponseFromJSON,
    TweetHideResponseToJSON,
    UsersLikesCreateRequestFromJSON,
    UsersLikesCreateRequestToJSON,
    UsersLikesCreateResponseFromJSON,
    UsersLikesCreateResponseToJSON,
    UsersLikesDeleteResponseFromJSON,
    UsersLikesDeleteResponseToJSON,
    UsersRetweetsCreateRequestFromJSON,
    UsersRetweetsCreateRequestToJSON,
    UsersRetweetsCreateResponseFromJSON,
    UsersRetweetsCreateResponseToJSON,
    UsersRetweetsDeleteResponseFromJSON,
    UsersRetweetsDeleteResponseToJSON,
} from '../models';

export interface AddOrDeleteRulesOperationRequest {
    addOrDeleteRulesRequest: AddOrDeleteRulesRequest;
    dryRun?: boolean;
}

export interface CreateTweetRequest {
    tweetCreateRequest: TweetCreateRequest;
}

export interface DeleteTweetByIdRequest {
    id: string;
}

export interface FindTweetByIdRequest {
    id: string;
    tweetFields?: Set<FindTweetByIdTweetFieldsEnum>;
    expansions?: Set<FindTweetByIdExpansionsEnum>;
    mediaFields?: Set<FindTweetByIdMediaFieldsEnum>;
    pollFields?: Set<FindTweetByIdPollFieldsEnum>;
    userFields?: Set<FindTweetByIdUserFieldsEnum>;
    placeFields?: Set<FindTweetByIdPlaceFieldsEnum>;
}

export interface FindTweetsByIdRequest {
    ids: Array<string>;
    tweetFields?: Set<FindTweetsByIdTweetFieldsEnum>;
    expansions?: Set<FindTweetsByIdExpansionsEnum>;
    mediaFields?: Set<FindTweetsByIdMediaFieldsEnum>;
    pollFields?: Set<FindTweetsByIdPollFieldsEnum>;
    userFields?: Set<FindTweetsByIdUserFieldsEnum>;
    placeFields?: Set<FindTweetsByIdPlaceFieldsEnum>;
}

export interface FindTweetsThatQuoteATweetRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    exclude?: Set<FindTweetsThatQuoteATweetExcludeEnum>;
    tweetFields?: Set<FindTweetsThatQuoteATweetTweetFieldsEnum>;
    expansions?: Set<FindTweetsThatQuoteATweetExpansionsEnum>;
    mediaFields?: Set<FindTweetsThatQuoteATweetMediaFieldsEnum>;
    pollFields?: Set<FindTweetsThatQuoteATweetPollFieldsEnum>;
    userFields?: Set<FindTweetsThatQuoteATweetUserFieldsEnum>;
    placeFields?: Set<FindTweetsThatQuoteATweetPlaceFieldsEnum>;
}

export interface GetRulesRequest {
    ids?: Array<string>;
    maxResults?: number;
    paginationToken?: string;
}

export interface GetTweetsFirehoseStreamRequest {
    partition: number;
    backfillMinutes?: number;
    startTime?: Date;
    endTime?: Date;
    tweetFields?: Set<GetTweetsFirehoseStreamTweetFieldsEnum>;
    expansions?: Set<GetTweetsFirehoseStreamExpansionsEnum>;
    mediaFields?: Set<GetTweetsFirehoseStreamMediaFieldsEnum>;
    pollFields?: Set<GetTweetsFirehoseStreamPollFieldsEnum>;
    userFields?: Set<GetTweetsFirehoseStreamUserFieldsEnum>;
    placeFields?: Set<GetTweetsFirehoseStreamPlaceFieldsEnum>;
}

export interface GetTweetsSample10StreamRequest {
    partition: number;
    backfillMinutes?: number;
    startTime?: Date;
    endTime?: Date;
    tweetFields?: Set<GetTweetsSample10StreamTweetFieldsEnum>;
    expansions?: Set<GetTweetsSample10StreamExpansionsEnum>;
    mediaFields?: Set<GetTweetsSample10StreamMediaFieldsEnum>;
    pollFields?: Set<GetTweetsSample10StreamPollFieldsEnum>;
    userFields?: Set<GetTweetsSample10StreamUserFieldsEnum>;
    placeFields?: Set<GetTweetsSample10StreamPlaceFieldsEnum>;
}

export interface HideReplyByIdRequest {
    tweetId: string;
    tweetHideRequest?: TweetHideRequest;
}

export interface ListsIdTweetsRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    tweetFields?: Set<ListsIdTweetsTweetFieldsEnum>;
    expansions?: Set<ListsIdTweetsExpansionsEnum>;
    mediaFields?: Set<ListsIdTweetsMediaFieldsEnum>;
    pollFields?: Set<ListsIdTweetsPollFieldsEnum>;
    userFields?: Set<ListsIdTweetsUserFieldsEnum>;
    placeFields?: Set<ListsIdTweetsPlaceFieldsEnum>;
}

export interface SampleStreamRequest {
    backfillMinutes?: number;
    tweetFields?: Set<SampleStreamTweetFieldsEnum>;
    expansions?: Set<SampleStreamExpansionsEnum>;
    mediaFields?: Set<SampleStreamMediaFieldsEnum>;
    pollFields?: Set<SampleStreamPollFieldsEnum>;
    userFields?: Set<SampleStreamUserFieldsEnum>;
    placeFields?: Set<SampleStreamPlaceFieldsEnum>;
}

export interface SearchStreamRequest {
    backfillMinutes?: number;
    startTime?: Date;
    endTime?: Date;
    tweetFields?: Set<SearchStreamTweetFieldsEnum>;
    expansions?: Set<SearchStreamExpansionsEnum>;
    mediaFields?: Set<SearchStreamMediaFieldsEnum>;
    pollFields?: Set<SearchStreamPollFieldsEnum>;
    userFields?: Set<SearchStreamUserFieldsEnum>;
    placeFields?: Set<SearchStreamPlaceFieldsEnum>;
}

export interface SpaceBuyersRequest {
    id: string;
    paginationToken?: string;
    maxResults?: number;
    userFields?: Set<SpaceBuyersUserFieldsEnum>;
    expansions?: Set<SpaceBuyersExpansionsEnum>;
    tweetFields?: Set<SpaceBuyersTweetFieldsEnum>;
}

export interface SpaceTweetsRequest {
    id: string;
    maxResults?: number;
    tweetFields?: Set<SpaceTweetsTweetFieldsEnum>;
    expansions?: Set<SpaceTweetsExpansionsEnum>;
    mediaFields?: Set<SpaceTweetsMediaFieldsEnum>;
    pollFields?: Set<SpaceTweetsPollFieldsEnum>;
    userFields?: Set<SpaceTweetsUserFieldsEnum>;
    placeFields?: Set<SpaceTweetsPlaceFieldsEnum>;
}

export interface TweetCountsFullArchiveSearchRequest {
    query: string;
    startTime?: Date;
    endTime?: Date;
    sinceId?: string;
    untilId?: string;
    nextToken?: string;
    paginationToken?: string;
    granularity?: TweetCountsFullArchiveSearchGranularityEnum;
    searchCountFields?: Set<TweetCountsFullArchiveSearchSearchCountFieldsEnum>;
}

export interface TweetCountsRecentSearchRequest {
    query: string;
    startTime?: Date;
    endTime?: Date;
    sinceId?: string;
    untilId?: string;
    nextToken?: string;
    paginationToken?: string;
    granularity?: TweetCountsRecentSearchGranularityEnum;
    searchCountFields?: Set<TweetCountsRecentSearchSearchCountFieldsEnum>;
}

export interface TweetsFullarchiveSearchRequest {
    query: string;
    startTime?: Date;
    endTime?: Date;
    sinceId?: string;
    untilId?: string;
    maxResults?: number;
    nextToken?: string;
    paginationToken?: string;
    sortOrder?: TweetsFullarchiveSearchSortOrderEnum;
    tweetFields?: Set<TweetsFullarchiveSearchTweetFieldsEnum>;
    expansions?: Set<TweetsFullarchiveSearchExpansionsEnum>;
    mediaFields?: Set<TweetsFullarchiveSearchMediaFieldsEnum>;
    pollFields?: Set<TweetsFullarchiveSearchPollFieldsEnum>;
    userFields?: Set<TweetsFullarchiveSearchUserFieldsEnum>;
    placeFields?: Set<TweetsFullarchiveSearchPlaceFieldsEnum>;
}

export interface TweetsRecentSearchRequest {
    query: string;
    startTime?: Date;
    endTime?: Date;
    sinceId?: string;
    untilId?: string;
    maxResults?: number;
    nextToken?: string;
    paginationToken?: string;
    sortOrder?: TweetsRecentSearchSortOrderEnum;
    tweetFields?: Set<TweetsRecentSearchTweetFieldsEnum>;
    expansions?: Set<TweetsRecentSearchExpansionsEnum>;
    mediaFields?: Set<TweetsRecentSearchMediaFieldsEnum>;
    pollFields?: Set<TweetsRecentSearchPollFieldsEnum>;
    userFields?: Set<TweetsRecentSearchUserFieldsEnum>;
    placeFields?: Set<TweetsRecentSearchPlaceFieldsEnum>;
}

export interface UsersIdLikeRequest {
    id: string;
    usersLikesCreateRequest?: UsersLikesCreateRequest;
}

export interface UsersIdLikedTweetsRequest {
    id: string;
    maxResults?: number;
    paginationToken?: string;
    tweetFields?: Set<UsersIdLikedTweetsTweetFieldsEnum>;
    expansions?: Set<UsersIdLikedTweetsExpansionsEnum>;
    mediaFields?: Set<UsersIdLikedTweetsMediaFieldsEnum>;
    pollFields?: Set<UsersIdLikedTweetsPollFieldsEnum>;
    userFields?: Set<UsersIdLikedTweetsUserFieldsEnum>;
    placeFields?: Set<UsersIdLikedTweetsPlaceFieldsEnum>;
}

export interface UsersIdMentionsRequest {
    id: string;
    sinceId?: string;
    untilId?: string;
    maxResults?: number;
    paginationToken?: string;
    startTime?: Date;
    endTime?: Date;
    tweetFields?: Set<UsersIdMentionsTweetFieldsEnum>;
    expansions?: Set<UsersIdMentionsExpansionsEnum>;
    mediaFields?: Set<UsersIdMentionsMediaFieldsEnum>;
    pollFields?: Set<UsersIdMentionsPollFieldsEnum>;
    userFields?: Set<UsersIdMentionsUserFieldsEnum>;
    placeFields?: Set<UsersIdMentionsPlaceFieldsEnum>;
}

export interface UsersIdRetweetsRequest {
    id: string;
    usersRetweetsCreateRequest?: UsersRetweetsCreateRequest;
}

export interface UsersIdTimelineRequest {
    id: string;
    sinceId?: string;
    untilId?: string;
    maxResults?: number;
    paginationToken?: string;
    exclude?: Set<UsersIdTimelineExcludeEnum>;
    startTime?: Date;
    endTime?: Date;
    tweetFields?: Set<UsersIdTimelineTweetFieldsEnum>;
    expansions?: Set<UsersIdTimelineExpansionsEnum>;
    mediaFields?: Set<UsersIdTimelineMediaFieldsEnum>;
    pollFields?: Set<UsersIdTimelinePollFieldsEnum>;
    userFields?: Set<UsersIdTimelineUserFieldsEnum>;
    placeFields?: Set<UsersIdTimelinePlaceFieldsEnum>;
}

export interface UsersIdTweetsRequest {
    id: string;
    sinceId?: string;
    untilId?: string;
    maxResults?: number;
    paginationToken?: string;
    exclude?: Set<UsersIdTweetsExcludeEnum>;
    startTime?: Date;
    endTime?: Date;
    tweetFields?: Set<UsersIdTweetsTweetFieldsEnum>;
    expansions?: Set<UsersIdTweetsExpansionsEnum>;
    mediaFields?: Set<UsersIdTweetsMediaFieldsEnum>;
    pollFields?: Set<UsersIdTweetsPollFieldsEnum>;
    userFields?: Set<UsersIdTweetsUserFieldsEnum>;
    placeFields?: Set<UsersIdTweetsPlaceFieldsEnum>;
}

export interface UsersIdUnlikeRequest {
    id: string;
    tweetId: string;
}

export interface UsersIdUnretweetsRequest {
    id: string;
    sourceTweetId: string;
}

/**
 * 
 */
export class TweetsApi extends runtime.BaseAPI {

    /**
     * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * Add/Delete rules
     */
    async addOrDeleteRulesRaw(requestParameters: AddOrDeleteRulesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddOrDeleteRulesResponse>> {
        if (requestParameters.addOrDeleteRulesRequest === null || requestParameters.addOrDeleteRulesRequest === undefined) {
            throw new runtime.RequiredError('addOrDeleteRulesRequest','Required parameter requestParameters.addOrDeleteRulesRequest was null or undefined when calling addOrDeleteRules.');
        }

        const queryParameters: any = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dry_run'] = requestParameters.dryRun;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/2/tweets/search/stream/rules`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddOrDeleteRulesRequestToJSON(requestParameters.addOrDeleteRulesRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddOrDeleteRulesResponseFromJSON(jsonValue));
    }

    /**
     * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * Add/Delete rules
     */
    async addOrDeleteRules(requestParameters: AddOrDeleteRulesOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddOrDeleteRulesResponse> {
        const response = await this.addOrDeleteRulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the User to create a Tweet under the authorized account.
     * Creation of a Tweet
     */
    async createTweetRaw(requestParameters: CreateTweetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TweetCreateResponse>> {
        if (requestParameters.tweetCreateRequest === null || requestParameters.tweetCreateRequest === undefined) {
            throw new runtime.RequiredError('tweetCreateRequest','Required parameter requestParameters.tweetCreateRequest was null or undefined when calling createTweet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "tweet.write"]);
        }

        const response = await this.request({
            path: `/2/tweets`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TweetCreateRequestToJSON(requestParameters.tweetCreateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TweetCreateResponseFromJSON(jsonValue));
    }

    /**
     * Causes the User to create a Tweet under the authorized account.
     * Creation of a Tweet
     */
    async createTweet(requestParameters: CreateTweetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TweetCreateResponse> {
        const response = await this.createTweetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete specified Tweet (in the path) by ID.
     * Tweet delete by Tweet ID
     */
    async deleteTweetByIdRaw(requestParameters: DeleteTweetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TweetDeleteResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteTweetById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "tweet.write"]);
        }

        const response = await this.request({
            path: `/2/tweets/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TweetDeleteResponseFromJSON(jsonValue));
    }

    /**
     * Delete specified Tweet (in the path) by ID.
     * Tweet delete by Tweet ID
     */
    async deleteTweetById(requestParameters: DeleteTweetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TweetDeleteResponse> {
        const response = await this.deleteTweetByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID.
     * Tweet lookup by Tweet ID
     */
    async findTweetByIdRaw(requestParameters: FindTweetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsIdResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling findTweetById.');
        }

        const queryParameters: any = {};

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/tweets/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsIdResponseFromJSON(jsonValue));
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID.
     * Tweet lookup by Tweet ID
     */
    async findTweetById(requestParameters: FindTweetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsIdResponse> {
        const response = await this.findTweetByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID.
     * Tweet lookup by Tweet IDs
     */
    async findTweetsByIdRaw(requestParameters: FindTweetsByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsResponse>> {
        if (requestParameters.ids === null || requestParameters.ids === undefined) {
            throw new runtime.RequiredError('ids','Required parameter requestParameters.ids was null or undefined when calling findTweetsById.');
        }

        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/tweets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID.
     * Tweet lookup by Tweet IDs
     */
    async findTweetsById(requestParameters: FindTweetsByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsResponse> {
        const response = await this.findTweetsByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
     * Retrieve Tweets that quote a Tweet.
     */
    async findTweetsThatQuoteATweetRaw(requestParameters: FindTweetsThatQuoteATweetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsIdQuoteTweetsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling findTweetsThatQuoteATweet.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.exclude) {
            queryParameters['exclude'] = Array.from(requestParameters.exclude).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/tweets/{id}/quote_tweets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsIdQuoteTweetsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
     * Retrieve Tweets that quote a Tweet.
     */
    async findTweetsThatQuoteATweet(requestParameters: FindTweetsThatQuoteATweetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsIdQuoteTweetsResponse> {
        const response = await this.findTweetsThatQuoteATweetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * Rules lookup
     */
    async getRulesRaw(requestParameters: GetRulesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RulesLookupResponse>> {
        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/2/tweets/search/stream/rules`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RulesLookupResponseFromJSON(jsonValue));
    }

    /**
     * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * Rules lookup
     */
    async getRules(requestParameters: GetRulesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RulesLookupResponse> {
        const response = await this.getRulesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Streams 100% of public Tweets.
     * Firehose stream
     */
    async getTweetsFirehoseStreamRaw(requestParameters: GetTweetsFirehoseStreamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamingTweetResponse>> {
        if (requestParameters.partition === null || requestParameters.partition === undefined) {
            throw new runtime.RequiredError('partition','Required parameter requestParameters.partition was null or undefined when calling getTweetsFirehoseStream.');
        }

        const queryParameters: any = {};

        if (requestParameters.backfillMinutes !== undefined) {
            queryParameters['backfill_minutes'] = requestParameters.backfillMinutes;
        }

        if (requestParameters.partition !== undefined) {
            queryParameters['partition'] = requestParameters.partition;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/2/tweets/firehose/stream`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamingTweetResponseFromJSON(jsonValue));
    }

    /**
     * Streams 100% of public Tweets.
     * Firehose stream
     */
    async getTweetsFirehoseStream(requestParameters: GetTweetsFirehoseStreamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamingTweetResponse> {
        const response = await this.getTweetsFirehoseStreamRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Streams a deterministic 10% of public Tweets.
     * Sample 10% stream
     */
    async getTweetsSample10StreamRaw(requestParameters: GetTweetsSample10StreamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsSample10StreamResponse>> {
        if (requestParameters.partition === null || requestParameters.partition === undefined) {
            throw new runtime.RequiredError('partition','Required parameter requestParameters.partition was null or undefined when calling getTweetsSample10Stream.');
        }

        const queryParameters: any = {};

        if (requestParameters.backfillMinutes !== undefined) {
            queryParameters['backfill_minutes'] = requestParameters.backfillMinutes;
        }

        if (requestParameters.partition !== undefined) {
            queryParameters['partition'] = requestParameters.partition;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/2/tweets/sample10/stream`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsSample10StreamResponseFromJSON(jsonValue));
    }

    /**
     * Streams a deterministic 10% of public Tweets.
     * Sample 10% stream
     */
    async getTweetsSample10Stream(requestParameters: GetTweetsSample10StreamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsSample10StreamResponse> {
        const response = await this.getTweetsSample10StreamRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Hides or unhides a reply to an owned conversation.
     * Hide replies
     */
    async hideReplyByIdRaw(requestParameters: HideReplyByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TweetHideResponse>> {
        if (requestParameters.tweetId === null || requestParameters.tweetId === undefined) {
            throw new runtime.RequiredError('tweetId','Required parameter requestParameters.tweetId was null or undefined when calling hideReplyById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "tweet.moderate.write"]);
        }

        const response = await this.request({
            path: `/2/tweets/{tweet_id}/hidden`.replace(`{${"tweet_id"}}`, encodeURIComponent(String(requestParameters.tweetId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: TweetHideRequestToJSON(requestParameters.tweetHideRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TweetHideResponseFromJSON(jsonValue));
    }

    /**
     * Hides or unhides a reply to an owned conversation.
     * Hide replies
     */
    async hideReplyById(requestParameters: HideReplyByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TweetHideResponse> {
        const response = await this.hideReplyByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Tweets associated with the provided List ID.
     * List Tweets timeline by List ID.
     */
    async listsIdTweetsRaw(requestParameters: ListsIdTweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2ListsIdTweetsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling listsIdTweets.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "list.read"]);
        }

        const response = await this.request({
            path: `/2/lists/{id}/tweets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2ListsIdTweetsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Tweets associated with the provided List ID.
     * List Tweets timeline by List ID.
     */
    async listsIdTweets(requestParameters: ListsIdTweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2ListsIdTweetsResponse> {
        const response = await this.listsIdTweetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Streams a deterministic 1% of public Tweets.
     * Sample stream
     */
    async sampleStreamRaw(requestParameters: SampleStreamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StreamingTweetResponse>> {
        const queryParameters: any = {};

        if (requestParameters.backfillMinutes !== undefined) {
            queryParameters['backfill_minutes'] = requestParameters.backfillMinutes;
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/2/tweets/sample/stream`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StreamingTweetResponseFromJSON(jsonValue));
    }

    /**
     * Streams a deterministic 1% of public Tweets.
     * Sample stream
     */
    async sampleStream(requestParameters: SampleStreamRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StreamingTweetResponse> {
        const response = await this.sampleStreamRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Streams Tweets matching the stream\'s active rule set.
     * Filtered stream
     */
    async searchStreamRaw(requestParameters: SearchStreamRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FilteredStreamingTweetResponse>> {
        const queryParameters: any = {};

        if (requestParameters.backfillMinutes !== undefined) {
            queryParameters['backfill_minutes'] = requestParameters.backfillMinutes;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/2/tweets/search/stream`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FilteredStreamingTweetResponseFromJSON(jsonValue));
    }

    /**
     * Streams Tweets matching the stream\'s active rule set.
     * Filtered stream
     */
    async searchStream(requestParameters: SearchStreamRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FilteredStreamingTweetResponse> {
        const response = await this.searchStreamRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the list of Users who purchased a ticket to the given space
     * Retrieve the list of Users who purchased a ticket to the given space
     */
    async spaceBuyersRaw(requestParameters: SpaceBuyersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2SpacesIdBuyersResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling spaceBuyers.');
        }

        const queryParameters: any = {};

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "space.read"]);
        }

        const response = await this.request({
            path: `/2/spaces/{id}/buyers`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2SpacesIdBuyersResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves the list of Users who purchased a ticket to the given space
     * Retrieve the list of Users who purchased a ticket to the given space
     */
    async spaceBuyers(requestParameters: SpaceBuyersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2SpacesIdBuyersResponse> {
        const response = await this.spaceBuyersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves Tweets shared in the specified Space.
     * Retrieve Tweets from a Space.
     */
    async spaceTweetsRaw(requestParameters: SpaceTweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2SpacesIdTweetsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling spaceTweets.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "space.read"]);
        }

        const response = await this.request({
            path: `/2/spaces/{id}/tweets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2SpacesIdTweetsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves Tweets shared in the specified Space.
     * Retrieve Tweets from a Space.
     */
    async spaceTweets(requestParameters: SpaceTweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2SpacesIdTweetsResponse> {
        const response = await this.spaceTweetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Tweet Counts that match a search query.
     * Full archive search counts
     */
    async tweetCountsFullArchiveSearchRaw(requestParameters: TweetCountsFullArchiveSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsCountsAllResponse>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling tweetCountsFullArchiveSearch.');
        }

        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.sinceId !== undefined) {
            queryParameters['since_id'] = requestParameters.sinceId;
        }

        if (requestParameters.untilId !== undefined) {
            queryParameters['until_id'] = requestParameters.untilId;
        }

        if (requestParameters.nextToken !== undefined) {
            queryParameters['next_token'] = requestParameters.nextToken;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.granularity !== undefined) {
            queryParameters['granularity'] = requestParameters.granularity;
        }

        if (requestParameters.searchCountFields) {
            queryParameters['search_count.fields'] = Array.from(requestParameters.searchCountFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/2/tweets/counts/all`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsCountsAllResponseFromJSON(jsonValue));
    }

    /**
     * Returns Tweet Counts that match a search query.
     * Full archive search counts
     */
    async tweetCountsFullArchiveSearch(requestParameters: TweetCountsFullArchiveSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsCountsAllResponse> {
        const response = await this.tweetCountsFullArchiveSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Tweet Counts from the last 7 days that match a search query.
     * Recent search counts
     */
    async tweetCountsRecentSearchRaw(requestParameters: TweetCountsRecentSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsCountsRecentResponse>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling tweetCountsRecentSearch.');
        }

        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.sinceId !== undefined) {
            queryParameters['since_id'] = requestParameters.sinceId;
        }

        if (requestParameters.untilId !== undefined) {
            queryParameters['until_id'] = requestParameters.untilId;
        }

        if (requestParameters.nextToken !== undefined) {
            queryParameters['next_token'] = requestParameters.nextToken;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.granularity !== undefined) {
            queryParameters['granularity'] = requestParameters.granularity;
        }

        if (requestParameters.searchCountFields) {
            queryParameters['search_count.fields'] = Array.from(requestParameters.searchCountFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/2/tweets/counts/recent`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsCountsRecentResponseFromJSON(jsonValue));
    }

    /**
     * Returns Tweet Counts from the last 7 days that match a search query.
     * Recent search counts
     */
    async tweetCountsRecentSearch(requestParameters: TweetCountsRecentSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsCountsRecentResponse> {
        const response = await this.tweetCountsRecentSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Tweets that match a search query.
     * Full-archive search
     */
    async tweetsFullarchiveSearchRaw(requestParameters: TweetsFullarchiveSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsSearchAllResponse>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling tweetsFullarchiveSearch.');
        }

        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.sinceId !== undefined) {
            queryParameters['since_id'] = requestParameters.sinceId;
        }

        if (requestParameters.untilId !== undefined) {
            queryParameters['until_id'] = requestParameters.untilId;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.nextToken !== undefined) {
            queryParameters['next_token'] = requestParameters.nextToken;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.sortOrder !== undefined) {
            queryParameters['sort_order'] = requestParameters.sortOrder;
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/2/tweets/search/all`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsSearchAllResponseFromJSON(jsonValue));
    }

    /**
     * Returns Tweets that match a search query.
     * Full-archive search
     */
    async tweetsFullarchiveSearch(requestParameters: TweetsFullarchiveSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsSearchAllResponse> {
        const response = await this.tweetsFullarchiveSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Tweets from the last 7 days that match a search query.
     * Recent search
     */
    async tweetsRecentSearchRaw(requestParameters: TweetsRecentSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2TweetsSearchRecentResponse>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling tweetsRecentSearch.');
        }

        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.sinceId !== undefined) {
            queryParameters['since_id'] = requestParameters.sinceId;
        }

        if (requestParameters.untilId !== undefined) {
            queryParameters['until_id'] = requestParameters.untilId;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.nextToken !== undefined) {
            queryParameters['next_token'] = requestParameters.nextToken;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.sortOrder !== undefined) {
            queryParameters['sort_order'] = requestParameters.sortOrder;
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/tweets/search/recent`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2TweetsSearchRecentResponseFromJSON(jsonValue));
    }

    /**
     * Returns Tweets from the last 7 days that match a search query.
     * Recent search
     */
    async tweetsRecentSearch(requestParameters: TweetsRecentSearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2TweetsSearchRecentResponse> {
        const response = await this.tweetsRecentSearchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
     * Causes the User (in the path) to like the specified Tweet
     */
    async usersIdLikeRaw(requestParameters: UsersIdLikeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersLikesCreateResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdLike.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "like.write"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/likes`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UsersLikesCreateRequestToJSON(requestParameters.usersLikesCreateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersLikesCreateResponseFromJSON(jsonValue));
    }

    /**
     * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
     * Causes the User (in the path) to like the specified Tweet
     */
    async usersIdLike(requestParameters: UsersIdLikeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersLikesCreateResponse> {
        const response = await this.usersIdLikeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Tweets liked by the provided User ID
     * Returns Tweet objects liked by the provided User ID
     */
    async usersIdLikedTweetsRaw(requestParameters: UsersIdLikedTweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersIdLikedTweetsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdLikedTweets.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "like.read"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/liked_tweets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersIdLikedTweetsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Tweets liked by the provided User ID
     * Returns Tweet objects liked by the provided User ID
     */
    async usersIdLikedTweets(requestParameters: UsersIdLikedTweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersIdLikedTweetsResponse> {
        const response = await this.usersIdLikedTweetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Tweet objects that mention username associated to the provided User ID
     * User mention timeline by User ID
     */
    async usersIdMentionsRaw(requestParameters: UsersIdMentionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersIdMentionsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdMentions.');
        }

        const queryParameters: any = {};

        if (requestParameters.sinceId !== undefined) {
            queryParameters['since_id'] = requestParameters.sinceId;
        }

        if (requestParameters.untilId !== undefined) {
            queryParameters['until_id'] = requestParameters.untilId;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/mentions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersIdMentionsResponseFromJSON(jsonValue));
    }

    /**
     * Returns Tweet objects that mention username associated to the provided User ID
     * User mention timeline by User ID
     */
    async usersIdMentions(requestParameters: UsersIdMentionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersIdMentionsResponse> {
        const response = await this.usersIdMentionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
     * Causes the User (in the path) to retweet the specified Tweet.
     */
    async usersIdRetweetsRaw(requestParameters: UsersIdRetweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersRetweetsCreateResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdRetweets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "tweet.write"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/retweets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UsersRetweetsCreateRequestToJSON(requestParameters.usersRetweetsCreateRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersRetweetsCreateResponseFromJSON(jsonValue));
    }

    /**
     * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
     * Causes the User (in the path) to retweet the specified Tweet.
     */
    async usersIdRetweets(requestParameters: UsersIdRetweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersRetweetsCreateResponse> {
        const response = await this.usersIdRetweetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns Tweet objects that appears in the provided User ID\'s home timeline
     * User home timeline by User ID
     */
    async usersIdTimelineRaw(requestParameters: UsersIdTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersIdTimelinesReverseChronologicalResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdTimeline.');
        }

        const queryParameters: any = {};

        if (requestParameters.sinceId !== undefined) {
            queryParameters['since_id'] = requestParameters.sinceId;
        }

        if (requestParameters.untilId !== undefined) {
            queryParameters['until_id'] = requestParameters.untilId;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.exclude) {
            queryParameters['exclude'] = Array.from(requestParameters.exclude).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/timelines/reverse_chronological`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersIdTimelinesReverseChronologicalResponseFromJSON(jsonValue));
    }

    /**
     * Returns Tweet objects that appears in the provided User ID\'s home timeline
     * User home timeline by User ID
     */
    async usersIdTimeline(requestParameters: UsersIdTimelineRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersIdTimelinesReverseChronologicalResponse> {
        const response = await this.usersIdTimelineRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of Tweets authored by the provided User ID
     * User Tweets timeline by User ID
     */
    async usersIdTweetsRaw(requestParameters: UsersIdTweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Get2UsersIdTweetsResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdTweets.');
        }

        const queryParameters: any = {};

        if (requestParameters.sinceId !== undefined) {
            queryParameters['since_id'] = requestParameters.sinceId;
        }

        if (requestParameters.untilId !== undefined) {
            queryParameters['until_id'] = requestParameters.untilId;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max_results'] = requestParameters.maxResults;
        }

        if (requestParameters.paginationToken !== undefined) {
            queryParameters['pagination_token'] = requestParameters.paginationToken;
        }

        if (requestParameters.exclude) {
            queryParameters['exclude'] = Array.from(requestParameters.exclude).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.startTime !== undefined) {
            queryParameters['start_time'] = (requestParameters.startTime as any).toISOString();
        }

        if (requestParameters.endTime !== undefined) {
            queryParameters['end_time'] = (requestParameters.endTime as any).toISOString();
        }

        if (requestParameters.tweetFields) {
            queryParameters['tweet.fields'] = Array.from(requestParameters.tweetFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.expansions) {
            queryParameters['expansions'] = Array.from(requestParameters.expansions).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.mediaFields) {
            queryParameters['media.fields'] = Array.from(requestParameters.mediaFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.pollFields) {
            queryParameters['poll.fields'] = Array.from(requestParameters.pollFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.userFields) {
            queryParameters['user.fields'] = Array.from(requestParameters.userFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.placeFields) {
            queryParameters['place.fields'] = Array.from(requestParameters.placeFields).join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerToken", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["tweet.read", "users.read"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/tweets`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Get2UsersIdTweetsResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of Tweets authored by the provided User ID
     * User Tweets timeline by User ID
     */
    async usersIdTweets(requestParameters: UsersIdTweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Get2UsersIdTweetsResponse> {
        const response = await this.usersIdTweetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
     * Causes the User (in the path) to unlike the specified Tweet
     */
    async usersIdUnlikeRaw(requestParameters: UsersIdUnlikeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersLikesDeleteResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdUnlike.');
        }

        if (requestParameters.tweetId === null || requestParameters.tweetId === undefined) {
            throw new runtime.RequiredError('tweetId','Required parameter requestParameters.tweetId was null or undefined when calling usersIdUnlike.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "like.write"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/likes/{tweet_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"tweet_id"}}`, encodeURIComponent(String(requestParameters.tweetId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersLikesDeleteResponseFromJSON(jsonValue));
    }

    /**
     * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
     * Causes the User (in the path) to unlike the specified Tweet
     */
    async usersIdUnlike(requestParameters: UsersIdUnlikeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersLikesDeleteResponse> {
        const response = await this.usersIdUnlikeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
     * Causes the User (in the path) to unretweet the specified Tweet
     */
    async usersIdUnretweetsRaw(requestParameters: UsersIdUnretweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UsersRetweetsDeleteResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling usersIdUnretweets.');
        }

        if (requestParameters.sourceTweetId === null || requestParameters.sourceTweetId === undefined) {
            throw new runtime.RequiredError('sourceTweetId','Required parameter requestParameters.sourceTweetId was null or undefined when calling usersIdUnretweets.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2UserToken", ["users.read", "tweet.read", "tweet.write"]);
        }

        const response = await this.request({
            path: `/2/users/{id}/retweets/{source_tweet_id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"source_tweet_id"}}`, encodeURIComponent(String(requestParameters.sourceTweetId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UsersRetweetsDeleteResponseFromJSON(jsonValue));
    }

    /**
     * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
     * Causes the User (in the path) to unretweet the specified Tweet
     */
    async usersIdUnretweets(requestParameters: UsersIdUnretweetsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UsersRetweetsDeleteResponse> {
        const response = await this.usersIdUnretweetsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const FindTweetByIdTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type FindTweetByIdTweetFieldsEnum = typeof FindTweetByIdTweetFieldsEnum[keyof typeof FindTweetByIdTweetFieldsEnum];
/**
 * @export
 */
export const FindTweetByIdExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type FindTweetByIdExpansionsEnum = typeof FindTweetByIdExpansionsEnum[keyof typeof FindTweetByIdExpansionsEnum];
/**
 * @export
 */
export const FindTweetByIdMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type FindTweetByIdMediaFieldsEnum = typeof FindTweetByIdMediaFieldsEnum[keyof typeof FindTweetByIdMediaFieldsEnum];
/**
 * @export
 */
export const FindTweetByIdPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type FindTweetByIdPollFieldsEnum = typeof FindTweetByIdPollFieldsEnum[keyof typeof FindTweetByIdPollFieldsEnum];
/**
 * @export
 */
export const FindTweetByIdUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type FindTweetByIdUserFieldsEnum = typeof FindTweetByIdUserFieldsEnum[keyof typeof FindTweetByIdUserFieldsEnum];
/**
 * @export
 */
export const FindTweetByIdPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type FindTweetByIdPlaceFieldsEnum = typeof FindTweetByIdPlaceFieldsEnum[keyof typeof FindTweetByIdPlaceFieldsEnum];
/**
 * @export
 */
export const FindTweetsByIdTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type FindTweetsByIdTweetFieldsEnum = typeof FindTweetsByIdTweetFieldsEnum[keyof typeof FindTweetsByIdTweetFieldsEnum];
/**
 * @export
 */
export const FindTweetsByIdExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type FindTweetsByIdExpansionsEnum = typeof FindTweetsByIdExpansionsEnum[keyof typeof FindTweetsByIdExpansionsEnum];
/**
 * @export
 */
export const FindTweetsByIdMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type FindTweetsByIdMediaFieldsEnum = typeof FindTweetsByIdMediaFieldsEnum[keyof typeof FindTweetsByIdMediaFieldsEnum];
/**
 * @export
 */
export const FindTweetsByIdPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type FindTweetsByIdPollFieldsEnum = typeof FindTweetsByIdPollFieldsEnum[keyof typeof FindTweetsByIdPollFieldsEnum];
/**
 * @export
 */
export const FindTweetsByIdUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type FindTweetsByIdUserFieldsEnum = typeof FindTweetsByIdUserFieldsEnum[keyof typeof FindTweetsByIdUserFieldsEnum];
/**
 * @export
 */
export const FindTweetsByIdPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type FindTweetsByIdPlaceFieldsEnum = typeof FindTweetsByIdPlaceFieldsEnum[keyof typeof FindTweetsByIdPlaceFieldsEnum];
/**
 * @export
 */
export const FindTweetsThatQuoteATweetExcludeEnum = {
    Replies: 'replies',
    Retweets: 'retweets'
} as const;
export type FindTweetsThatQuoteATweetExcludeEnum = typeof FindTweetsThatQuoteATweetExcludeEnum[keyof typeof FindTweetsThatQuoteATweetExcludeEnum];
/**
 * @export
 */
export const FindTweetsThatQuoteATweetTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type FindTweetsThatQuoteATweetTweetFieldsEnum = typeof FindTweetsThatQuoteATweetTweetFieldsEnum[keyof typeof FindTweetsThatQuoteATweetTweetFieldsEnum];
/**
 * @export
 */
export const FindTweetsThatQuoteATweetExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type FindTweetsThatQuoteATweetExpansionsEnum = typeof FindTweetsThatQuoteATweetExpansionsEnum[keyof typeof FindTweetsThatQuoteATweetExpansionsEnum];
/**
 * @export
 */
export const FindTweetsThatQuoteATweetMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type FindTweetsThatQuoteATweetMediaFieldsEnum = typeof FindTweetsThatQuoteATweetMediaFieldsEnum[keyof typeof FindTweetsThatQuoteATweetMediaFieldsEnum];
/**
 * @export
 */
export const FindTweetsThatQuoteATweetPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type FindTweetsThatQuoteATweetPollFieldsEnum = typeof FindTweetsThatQuoteATweetPollFieldsEnum[keyof typeof FindTweetsThatQuoteATweetPollFieldsEnum];
/**
 * @export
 */
export const FindTweetsThatQuoteATweetUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type FindTweetsThatQuoteATweetUserFieldsEnum = typeof FindTweetsThatQuoteATweetUserFieldsEnum[keyof typeof FindTweetsThatQuoteATweetUserFieldsEnum];
/**
 * @export
 */
export const FindTweetsThatQuoteATweetPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type FindTweetsThatQuoteATweetPlaceFieldsEnum = typeof FindTweetsThatQuoteATweetPlaceFieldsEnum[keyof typeof FindTweetsThatQuoteATweetPlaceFieldsEnum];
/**
 * @export
 */
export const GetTweetsFirehoseStreamTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type GetTweetsFirehoseStreamTweetFieldsEnum = typeof GetTweetsFirehoseStreamTweetFieldsEnum[keyof typeof GetTweetsFirehoseStreamTweetFieldsEnum];
/**
 * @export
 */
export const GetTweetsFirehoseStreamExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type GetTweetsFirehoseStreamExpansionsEnum = typeof GetTweetsFirehoseStreamExpansionsEnum[keyof typeof GetTweetsFirehoseStreamExpansionsEnum];
/**
 * @export
 */
export const GetTweetsFirehoseStreamMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type GetTweetsFirehoseStreamMediaFieldsEnum = typeof GetTweetsFirehoseStreamMediaFieldsEnum[keyof typeof GetTweetsFirehoseStreamMediaFieldsEnum];
/**
 * @export
 */
export const GetTweetsFirehoseStreamPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type GetTweetsFirehoseStreamPollFieldsEnum = typeof GetTweetsFirehoseStreamPollFieldsEnum[keyof typeof GetTweetsFirehoseStreamPollFieldsEnum];
/**
 * @export
 */
export const GetTweetsFirehoseStreamUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type GetTweetsFirehoseStreamUserFieldsEnum = typeof GetTweetsFirehoseStreamUserFieldsEnum[keyof typeof GetTweetsFirehoseStreamUserFieldsEnum];
/**
 * @export
 */
export const GetTweetsFirehoseStreamPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type GetTweetsFirehoseStreamPlaceFieldsEnum = typeof GetTweetsFirehoseStreamPlaceFieldsEnum[keyof typeof GetTweetsFirehoseStreamPlaceFieldsEnum];
/**
 * @export
 */
export const GetTweetsSample10StreamTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type GetTweetsSample10StreamTweetFieldsEnum = typeof GetTweetsSample10StreamTweetFieldsEnum[keyof typeof GetTweetsSample10StreamTweetFieldsEnum];
/**
 * @export
 */
export const GetTweetsSample10StreamExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type GetTweetsSample10StreamExpansionsEnum = typeof GetTweetsSample10StreamExpansionsEnum[keyof typeof GetTweetsSample10StreamExpansionsEnum];
/**
 * @export
 */
export const GetTweetsSample10StreamMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type GetTweetsSample10StreamMediaFieldsEnum = typeof GetTweetsSample10StreamMediaFieldsEnum[keyof typeof GetTweetsSample10StreamMediaFieldsEnum];
/**
 * @export
 */
export const GetTweetsSample10StreamPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type GetTweetsSample10StreamPollFieldsEnum = typeof GetTweetsSample10StreamPollFieldsEnum[keyof typeof GetTweetsSample10StreamPollFieldsEnum];
/**
 * @export
 */
export const GetTweetsSample10StreamUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type GetTweetsSample10StreamUserFieldsEnum = typeof GetTweetsSample10StreamUserFieldsEnum[keyof typeof GetTweetsSample10StreamUserFieldsEnum];
/**
 * @export
 */
export const GetTweetsSample10StreamPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type GetTweetsSample10StreamPlaceFieldsEnum = typeof GetTweetsSample10StreamPlaceFieldsEnum[keyof typeof GetTweetsSample10StreamPlaceFieldsEnum];
/**
 * @export
 */
export const ListsIdTweetsTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type ListsIdTweetsTweetFieldsEnum = typeof ListsIdTweetsTweetFieldsEnum[keyof typeof ListsIdTweetsTweetFieldsEnum];
/**
 * @export
 */
export const ListsIdTweetsExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type ListsIdTweetsExpansionsEnum = typeof ListsIdTweetsExpansionsEnum[keyof typeof ListsIdTweetsExpansionsEnum];
/**
 * @export
 */
export const ListsIdTweetsMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type ListsIdTweetsMediaFieldsEnum = typeof ListsIdTweetsMediaFieldsEnum[keyof typeof ListsIdTweetsMediaFieldsEnum];
/**
 * @export
 */
export const ListsIdTweetsPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type ListsIdTweetsPollFieldsEnum = typeof ListsIdTweetsPollFieldsEnum[keyof typeof ListsIdTweetsPollFieldsEnum];
/**
 * @export
 */
export const ListsIdTweetsUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type ListsIdTweetsUserFieldsEnum = typeof ListsIdTweetsUserFieldsEnum[keyof typeof ListsIdTweetsUserFieldsEnum];
/**
 * @export
 */
export const ListsIdTweetsPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type ListsIdTweetsPlaceFieldsEnum = typeof ListsIdTweetsPlaceFieldsEnum[keyof typeof ListsIdTweetsPlaceFieldsEnum];
/**
 * @export
 */
export const SampleStreamTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type SampleStreamTweetFieldsEnum = typeof SampleStreamTweetFieldsEnum[keyof typeof SampleStreamTweetFieldsEnum];
/**
 * @export
 */
export const SampleStreamExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type SampleStreamExpansionsEnum = typeof SampleStreamExpansionsEnum[keyof typeof SampleStreamExpansionsEnum];
/**
 * @export
 */
export const SampleStreamMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type SampleStreamMediaFieldsEnum = typeof SampleStreamMediaFieldsEnum[keyof typeof SampleStreamMediaFieldsEnum];
/**
 * @export
 */
export const SampleStreamPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type SampleStreamPollFieldsEnum = typeof SampleStreamPollFieldsEnum[keyof typeof SampleStreamPollFieldsEnum];
/**
 * @export
 */
export const SampleStreamUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type SampleStreamUserFieldsEnum = typeof SampleStreamUserFieldsEnum[keyof typeof SampleStreamUserFieldsEnum];
/**
 * @export
 */
export const SampleStreamPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type SampleStreamPlaceFieldsEnum = typeof SampleStreamPlaceFieldsEnum[keyof typeof SampleStreamPlaceFieldsEnum];
/**
 * @export
 */
export const SearchStreamTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type SearchStreamTweetFieldsEnum = typeof SearchStreamTweetFieldsEnum[keyof typeof SearchStreamTweetFieldsEnum];
/**
 * @export
 */
export const SearchStreamExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type SearchStreamExpansionsEnum = typeof SearchStreamExpansionsEnum[keyof typeof SearchStreamExpansionsEnum];
/**
 * @export
 */
export const SearchStreamMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type SearchStreamMediaFieldsEnum = typeof SearchStreamMediaFieldsEnum[keyof typeof SearchStreamMediaFieldsEnum];
/**
 * @export
 */
export const SearchStreamPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type SearchStreamPollFieldsEnum = typeof SearchStreamPollFieldsEnum[keyof typeof SearchStreamPollFieldsEnum];
/**
 * @export
 */
export const SearchStreamUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type SearchStreamUserFieldsEnum = typeof SearchStreamUserFieldsEnum[keyof typeof SearchStreamUserFieldsEnum];
/**
 * @export
 */
export const SearchStreamPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type SearchStreamPlaceFieldsEnum = typeof SearchStreamPlaceFieldsEnum[keyof typeof SearchStreamPlaceFieldsEnum];
/**
 * @export
 */
export const SpaceBuyersUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type SpaceBuyersUserFieldsEnum = typeof SpaceBuyersUserFieldsEnum[keyof typeof SpaceBuyersUserFieldsEnum];
/**
 * @export
 */
export const SpaceBuyersExpansionsEnum = {
    PinnedTweetId: 'pinned_tweet_id'
} as const;
export type SpaceBuyersExpansionsEnum = typeof SpaceBuyersExpansionsEnum[keyof typeof SpaceBuyersExpansionsEnum];
/**
 * @export
 */
export const SpaceBuyersTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type SpaceBuyersTweetFieldsEnum = typeof SpaceBuyersTweetFieldsEnum[keyof typeof SpaceBuyersTweetFieldsEnum];
/**
 * @export
 */
export const SpaceTweetsTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type SpaceTweetsTweetFieldsEnum = typeof SpaceTweetsTweetFieldsEnum[keyof typeof SpaceTweetsTweetFieldsEnum];
/**
 * @export
 */
export const SpaceTweetsExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type SpaceTweetsExpansionsEnum = typeof SpaceTweetsExpansionsEnum[keyof typeof SpaceTweetsExpansionsEnum];
/**
 * @export
 */
export const SpaceTweetsMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type SpaceTweetsMediaFieldsEnum = typeof SpaceTweetsMediaFieldsEnum[keyof typeof SpaceTweetsMediaFieldsEnum];
/**
 * @export
 */
export const SpaceTweetsPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type SpaceTweetsPollFieldsEnum = typeof SpaceTweetsPollFieldsEnum[keyof typeof SpaceTweetsPollFieldsEnum];
/**
 * @export
 */
export const SpaceTweetsUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type SpaceTweetsUserFieldsEnum = typeof SpaceTweetsUserFieldsEnum[keyof typeof SpaceTweetsUserFieldsEnum];
/**
 * @export
 */
export const SpaceTweetsPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type SpaceTweetsPlaceFieldsEnum = typeof SpaceTweetsPlaceFieldsEnum[keyof typeof SpaceTweetsPlaceFieldsEnum];
/**
 * @export
 */
export const TweetCountsFullArchiveSearchGranularityEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day'
} as const;
export type TweetCountsFullArchiveSearchGranularityEnum = typeof TweetCountsFullArchiveSearchGranularityEnum[keyof typeof TweetCountsFullArchiveSearchGranularityEnum];
/**
 * @export
 */
export const TweetCountsFullArchiveSearchSearchCountFieldsEnum = {
    End: 'end',
    Start: 'start',
    TweetCount: 'tweet_count'
} as const;
export type TweetCountsFullArchiveSearchSearchCountFieldsEnum = typeof TweetCountsFullArchiveSearchSearchCountFieldsEnum[keyof typeof TweetCountsFullArchiveSearchSearchCountFieldsEnum];
/**
 * @export
 */
export const TweetCountsRecentSearchGranularityEnum = {
    Minute: 'minute',
    Hour: 'hour',
    Day: 'day'
} as const;
export type TweetCountsRecentSearchGranularityEnum = typeof TweetCountsRecentSearchGranularityEnum[keyof typeof TweetCountsRecentSearchGranularityEnum];
/**
 * @export
 */
export const TweetCountsRecentSearchSearchCountFieldsEnum = {
    End: 'end',
    Start: 'start',
    TweetCount: 'tweet_count'
} as const;
export type TweetCountsRecentSearchSearchCountFieldsEnum = typeof TweetCountsRecentSearchSearchCountFieldsEnum[keyof typeof TweetCountsRecentSearchSearchCountFieldsEnum];
/**
 * @export
 */
export const TweetsFullarchiveSearchSortOrderEnum = {
    Recency: 'recency',
    Relevancy: 'relevancy'
} as const;
export type TweetsFullarchiveSearchSortOrderEnum = typeof TweetsFullarchiveSearchSortOrderEnum[keyof typeof TweetsFullarchiveSearchSortOrderEnum];
/**
 * @export
 */
export const TweetsFullarchiveSearchTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type TweetsFullarchiveSearchTweetFieldsEnum = typeof TweetsFullarchiveSearchTweetFieldsEnum[keyof typeof TweetsFullarchiveSearchTweetFieldsEnum];
/**
 * @export
 */
export const TweetsFullarchiveSearchExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type TweetsFullarchiveSearchExpansionsEnum = typeof TweetsFullarchiveSearchExpansionsEnum[keyof typeof TweetsFullarchiveSearchExpansionsEnum];
/**
 * @export
 */
export const TweetsFullarchiveSearchMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type TweetsFullarchiveSearchMediaFieldsEnum = typeof TweetsFullarchiveSearchMediaFieldsEnum[keyof typeof TweetsFullarchiveSearchMediaFieldsEnum];
/**
 * @export
 */
export const TweetsFullarchiveSearchPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type TweetsFullarchiveSearchPollFieldsEnum = typeof TweetsFullarchiveSearchPollFieldsEnum[keyof typeof TweetsFullarchiveSearchPollFieldsEnum];
/**
 * @export
 */
export const TweetsFullarchiveSearchUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type TweetsFullarchiveSearchUserFieldsEnum = typeof TweetsFullarchiveSearchUserFieldsEnum[keyof typeof TweetsFullarchiveSearchUserFieldsEnum];
/**
 * @export
 */
export const TweetsFullarchiveSearchPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type TweetsFullarchiveSearchPlaceFieldsEnum = typeof TweetsFullarchiveSearchPlaceFieldsEnum[keyof typeof TweetsFullarchiveSearchPlaceFieldsEnum];
/**
 * @export
 */
export const TweetsRecentSearchSortOrderEnum = {
    Recency: 'recency',
    Relevancy: 'relevancy'
} as const;
export type TweetsRecentSearchSortOrderEnum = typeof TweetsRecentSearchSortOrderEnum[keyof typeof TweetsRecentSearchSortOrderEnum];
/**
 * @export
 */
export const TweetsRecentSearchTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type TweetsRecentSearchTweetFieldsEnum = typeof TweetsRecentSearchTweetFieldsEnum[keyof typeof TweetsRecentSearchTweetFieldsEnum];
/**
 * @export
 */
export const TweetsRecentSearchExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type TweetsRecentSearchExpansionsEnum = typeof TweetsRecentSearchExpansionsEnum[keyof typeof TweetsRecentSearchExpansionsEnum];
/**
 * @export
 */
export const TweetsRecentSearchMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type TweetsRecentSearchMediaFieldsEnum = typeof TweetsRecentSearchMediaFieldsEnum[keyof typeof TweetsRecentSearchMediaFieldsEnum];
/**
 * @export
 */
export const TweetsRecentSearchPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type TweetsRecentSearchPollFieldsEnum = typeof TweetsRecentSearchPollFieldsEnum[keyof typeof TweetsRecentSearchPollFieldsEnum];
/**
 * @export
 */
export const TweetsRecentSearchUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type TweetsRecentSearchUserFieldsEnum = typeof TweetsRecentSearchUserFieldsEnum[keyof typeof TweetsRecentSearchUserFieldsEnum];
/**
 * @export
 */
export const TweetsRecentSearchPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type TweetsRecentSearchPlaceFieldsEnum = typeof TweetsRecentSearchPlaceFieldsEnum[keyof typeof TweetsRecentSearchPlaceFieldsEnum];
/**
 * @export
 */
export const UsersIdLikedTweetsTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type UsersIdLikedTweetsTweetFieldsEnum = typeof UsersIdLikedTweetsTweetFieldsEnum[keyof typeof UsersIdLikedTweetsTweetFieldsEnum];
/**
 * @export
 */
export const UsersIdLikedTweetsExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type UsersIdLikedTweetsExpansionsEnum = typeof UsersIdLikedTweetsExpansionsEnum[keyof typeof UsersIdLikedTweetsExpansionsEnum];
/**
 * @export
 */
export const UsersIdLikedTweetsMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type UsersIdLikedTweetsMediaFieldsEnum = typeof UsersIdLikedTweetsMediaFieldsEnum[keyof typeof UsersIdLikedTweetsMediaFieldsEnum];
/**
 * @export
 */
export const UsersIdLikedTweetsPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type UsersIdLikedTweetsPollFieldsEnum = typeof UsersIdLikedTweetsPollFieldsEnum[keyof typeof UsersIdLikedTweetsPollFieldsEnum];
/**
 * @export
 */
export const UsersIdLikedTweetsUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type UsersIdLikedTweetsUserFieldsEnum = typeof UsersIdLikedTweetsUserFieldsEnum[keyof typeof UsersIdLikedTweetsUserFieldsEnum];
/**
 * @export
 */
export const UsersIdLikedTweetsPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type UsersIdLikedTweetsPlaceFieldsEnum = typeof UsersIdLikedTweetsPlaceFieldsEnum[keyof typeof UsersIdLikedTweetsPlaceFieldsEnum];
/**
 * @export
 */
export const UsersIdMentionsTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type UsersIdMentionsTweetFieldsEnum = typeof UsersIdMentionsTweetFieldsEnum[keyof typeof UsersIdMentionsTweetFieldsEnum];
/**
 * @export
 */
export const UsersIdMentionsExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type UsersIdMentionsExpansionsEnum = typeof UsersIdMentionsExpansionsEnum[keyof typeof UsersIdMentionsExpansionsEnum];
/**
 * @export
 */
export const UsersIdMentionsMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type UsersIdMentionsMediaFieldsEnum = typeof UsersIdMentionsMediaFieldsEnum[keyof typeof UsersIdMentionsMediaFieldsEnum];
/**
 * @export
 */
export const UsersIdMentionsPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type UsersIdMentionsPollFieldsEnum = typeof UsersIdMentionsPollFieldsEnum[keyof typeof UsersIdMentionsPollFieldsEnum];
/**
 * @export
 */
export const UsersIdMentionsUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type UsersIdMentionsUserFieldsEnum = typeof UsersIdMentionsUserFieldsEnum[keyof typeof UsersIdMentionsUserFieldsEnum];
/**
 * @export
 */
export const UsersIdMentionsPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type UsersIdMentionsPlaceFieldsEnum = typeof UsersIdMentionsPlaceFieldsEnum[keyof typeof UsersIdMentionsPlaceFieldsEnum];
/**
 * @export
 */
export const UsersIdTimelineExcludeEnum = {
    Replies: 'replies',
    Retweets: 'retweets'
} as const;
export type UsersIdTimelineExcludeEnum = typeof UsersIdTimelineExcludeEnum[keyof typeof UsersIdTimelineExcludeEnum];
/**
 * @export
 */
export const UsersIdTimelineTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type UsersIdTimelineTweetFieldsEnum = typeof UsersIdTimelineTweetFieldsEnum[keyof typeof UsersIdTimelineTweetFieldsEnum];
/**
 * @export
 */
export const UsersIdTimelineExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type UsersIdTimelineExpansionsEnum = typeof UsersIdTimelineExpansionsEnum[keyof typeof UsersIdTimelineExpansionsEnum];
/**
 * @export
 */
export const UsersIdTimelineMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type UsersIdTimelineMediaFieldsEnum = typeof UsersIdTimelineMediaFieldsEnum[keyof typeof UsersIdTimelineMediaFieldsEnum];
/**
 * @export
 */
export const UsersIdTimelinePollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type UsersIdTimelinePollFieldsEnum = typeof UsersIdTimelinePollFieldsEnum[keyof typeof UsersIdTimelinePollFieldsEnum];
/**
 * @export
 */
export const UsersIdTimelineUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type UsersIdTimelineUserFieldsEnum = typeof UsersIdTimelineUserFieldsEnum[keyof typeof UsersIdTimelineUserFieldsEnum];
/**
 * @export
 */
export const UsersIdTimelinePlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type UsersIdTimelinePlaceFieldsEnum = typeof UsersIdTimelinePlaceFieldsEnum[keyof typeof UsersIdTimelinePlaceFieldsEnum];
/**
 * @export
 */
export const UsersIdTweetsExcludeEnum = {
    Replies: 'replies',
    Retweets: 'retweets'
} as const;
export type UsersIdTweetsExcludeEnum = typeof UsersIdTweetsExcludeEnum[keyof typeof UsersIdTweetsExcludeEnum];
/**
 * @export
 */
export const UsersIdTweetsTweetFieldsEnum = {
    Attachments: 'attachments',
    AuthorId: 'author_id',
    ContextAnnotations: 'context_annotations',
    ConversationId: 'conversation_id',
    CreatedAt: 'created_at',
    Entities: 'entities',
    Geo: 'geo',
    Id: 'id',
    InReplyToUserId: 'in_reply_to_user_id',
    Lang: 'lang',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PossiblySensitive: 'possibly_sensitive',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    ReferencedTweets: 'referenced_tweets',
    ReplySettings: 'reply_settings',
    Source: 'source',
    Text: 'text',
    Withheld: 'withheld'
} as const;
export type UsersIdTweetsTweetFieldsEnum = typeof UsersIdTweetsTweetFieldsEnum[keyof typeof UsersIdTweetsTweetFieldsEnum];
/**
 * @export
 */
export const UsersIdTweetsExpansionsEnum = {
    AttachmentsMediaKeys: 'attachments.media_keys',
    AttachmentsPollIds: 'attachments.poll_ids',
    AuthorId: 'author_id',
    EntitiesMentionsUsername: 'entities.mentions.username',
    GeoPlaceId: 'geo.place_id',
    InReplyToUserId: 'in_reply_to_user_id',
    ReferencedTweetsId: 'referenced_tweets.id',
    ReferencedTweetsIdAuthorId: 'referenced_tweets.id.author_id'
} as const;
export type UsersIdTweetsExpansionsEnum = typeof UsersIdTweetsExpansionsEnum[keyof typeof UsersIdTweetsExpansionsEnum];
/**
 * @export
 */
export const UsersIdTweetsMediaFieldsEnum = {
    AltText: 'alt_text',
    DurationMs: 'duration_ms',
    Height: 'height',
    MediaKey: 'media_key',
    NonPublicMetrics: 'non_public_metrics',
    OrganicMetrics: 'organic_metrics',
    PreviewImageUrl: 'preview_image_url',
    PromotedMetrics: 'promoted_metrics',
    PublicMetrics: 'public_metrics',
    Type: 'type',
    Url: 'url',
    Variants: 'variants',
    Width: 'width'
} as const;
export type UsersIdTweetsMediaFieldsEnum = typeof UsersIdTweetsMediaFieldsEnum[keyof typeof UsersIdTweetsMediaFieldsEnum];
/**
 * @export
 */
export const UsersIdTweetsPollFieldsEnum = {
    DurationMinutes: 'duration_minutes',
    EndDatetime: 'end_datetime',
    Id: 'id',
    Options: 'options',
    VotingStatus: 'voting_status'
} as const;
export type UsersIdTweetsPollFieldsEnum = typeof UsersIdTweetsPollFieldsEnum[keyof typeof UsersIdTweetsPollFieldsEnum];
/**
 * @export
 */
export const UsersIdTweetsUserFieldsEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Entities: 'entities',
    Id: 'id',
    Location: 'location',
    Name: 'name',
    PinnedTweetId: 'pinned_tweet_id',
    ProfileImageUrl: 'profile_image_url',
    Protected: 'protected',
    PublicMetrics: 'public_metrics',
    Url: 'url',
    Username: 'username',
    Verified: 'verified',
    Withheld: 'withheld'
} as const;
export type UsersIdTweetsUserFieldsEnum = typeof UsersIdTweetsUserFieldsEnum[keyof typeof UsersIdTweetsUserFieldsEnum];
/**
 * @export
 */
export const UsersIdTweetsPlaceFieldsEnum = {
    ContainedWithin: 'contained_within',
    Country: 'country',
    CountryCode: 'country_code',
    FullName: 'full_name',
    Geo: 'geo',
    Id: 'id',
    Name: 'name',
    PlaceType: 'place_type'
} as const;
export type UsersIdTweetsPlaceFieldsEnum = typeof UsersIdTweetsPlaceFieldsEnum[keyof typeof UsersIdTweetsPlaceFieldsEnum];
